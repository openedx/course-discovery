"""Models for the programs app."""
# pylint: disable=model-missing-unicode,no-member
from django.db import models
from django.core.exceptions import ValidationError
from django.utils.translation import ugettext_lazy as _
from django_extensions.db.models import TimeStampedModel

from course_discovery.apps.course_metadata.models import Organization, Seat
from course_discovery.apps.programs import constants


def _choices(*values):
    """
    Helper for use with model field 'choices'.
    """
    return [(value, ) * 2 for value in values]


class Program(TimeStampedModel):
    """
    Representation of a Program.
    """
    external_id = models.IntegerField()

    name = models.CharField(
        help_text=_('The user-facing display name for this Program.'),
        max_length=255,
        unique=True,
    )

    subtitle = models.CharField(
        help_text=_('A brief, descriptive subtitle for the Program.'),
        max_length=255,
        blank=True,
    )

    category = models.CharField(
        help_text=_('The category / type of Program.'),
        max_length=32,
        choices=_choices(constants.ProgramCategory.XSERIES),
    )

    status = models.CharField(
        help_text=_('The lifecycle status of this Program.'),
        max_length=24,
        choices=_choices(
            constants.ProgramStatus.UNPUBLISHED,
            constants.ProgramStatus.ACTIVE,
            constants.ProgramStatus.RETIRED,
            constants.ProgramStatus.DELETED,
        ),
        default=constants.ProgramStatus.UNPUBLISHED,
        # though this field is not nullable, setting blank=True ensures validators
        # will reject the empty string, instead of implicitly replacing it with the
        # default value.  This is consistent with how None/null is handled.
        blank=True,
    )

    marketing_slug = models.CharField(
        help_text=_('Slug used to generate links to the marketing site'),
        blank=True,
        max_length=255
    )

    def save(self, *a, **kw):
        """
        Verify that the marketing slug is not empty if the user has attempted
        to activate an XSeries.
        """
        if self.category == constants.ProgramCategory.XSERIES and self.status == constants.ProgramStatus.ACTIVE:
            if not self.marketing_slug:
                raise ValidationError(_(
                    "Active XSeries Programs must have a valid marketing slug."
                ))

        return super(Program, self).save(*a, **kw)

    class Meta(object):  # pylint: disable=missing-docstring
        index_together = ('status', 'category')

    def __str__(self):
        return self.name


class ProgramOrganization(TimeStampedModel):
    """
    This is a m2m table that would otherwise be automatically generated by django's ORM.
    By defining it explicity here, we can use TimeStampedModel, and have an easier path
    to further accessing or customizing the model's data / methods as needed.
    """
    program = models.ForeignKey(Program)
    organization = models.ForeignKey(Organization)

    # TODO: we may need validation to ensure that you cannot remove a program's
    # org association if the program contains course requirements that are associated
    # with that org.
    def save(self, *a, **kw):
        """
        Prevent more than one org from being associated with a program.
        This is a temporary, application-level constraint.
        """
        if not self.id:  # pylint: disable=no-member
            # Before creating, check program is not already associated with some organization
            if ProgramOrganization.objects.filter(program=self.program).exists():
                raise ValidationError(_('Cannot associate multiple organizations with a program.'))

        return super(ProgramOrganization, self).save(*a, **kw)


class CourseRequirement(TimeStampedModel):
    """
    Represents a program's course requirement independent of run / mode.
    This is used to link multiple runs / modes of the same course offering within a program,
    both for purposes of presentation and in order to enforce logic
    associated with program completion (i.e. one completed run for each
    course requirement in the program indicates completion of the program).
    """
    organization = models.ForeignKey(Organization)
    key = models.CharField(
        help_text=_(
            "The 'course' part of course_keys associated with this course requirement, "
            "for example 'DemoX' in 'edX/DemoX/Demo_Course'."
        ),
        max_length=64,
    )
    display_name = models.CharField(
        help_text=_('The display name of this course requirement.'),
        max_length=128,
    )
    programs = models.ManyToManyField(Program, related_name='course_requirements', through='ProgramCourseRequirement')
    programs = models.ManyToManyField(Seat)

    class Meta(object):  # pylint: disable=missing-docstring
        unique_together = ('organization', 'key')

    def __str__(self):
        return self.display_name


class ProgramCourseRequirement(TimeStampedModel):
    """
    Represents the many-to-many association of a requirement with a program.
    """
    program = models.ForeignKey(Program)
    course_requirement = models.ForeignKey(CourseRequirement)
    position = models.IntegerField()

    class Meta(object):  # pylint: disable=missing-docstring
        unique_together = ('program', 'position')
        ordering = ['position']

    def __str__(self):
        return self.course_requirement

    def save(self, *a, **kw):
        """
        Override save() to validate m2m cardinality and automatically set the position for a new row.
        """
        if self.position is None:
            # before creating, check that course requirement is not associated with another program
            if ProgramCourseRequirement.objects.filter(course_requirement=self.course_requirement).exists():
                raise ValidationError(_('Cannot associate multiple programs with a course requirement.'))
            # before creating, ensure that the program has an association with the same org as this course code
            if not ProgramOrganization.objects.filter(
                    program=self.program, organization=self.course_requirement.organization).exists():
                raise ValidationError(
                    _('Course requirement must be offered by the same organization offering the program.')
                )
            # automatically set position attribute for a new row
            res = ProgramCourseRequirement.objects.filter(program=self.program).aggregate(
                max_position=models.Max('position')
            )
            self.position = (res['max_position'] or 0) + 1
        return super(ProgramCourseRequirement, self).save(*a, **kw)
